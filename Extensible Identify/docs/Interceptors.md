# What is an interceptor

Interceptor is one of extensible points of Safewhere Identify that allows for intercepting login flows when:

- [Authentication connection's interceptor](CodeReferences/IAuthenticationInterceptorService.cs): this type of interceptor is invoked after Identify receives a token, but before Identify creates a login session for a user. This enables some good use cases such as custom validation rules for claims that an Identity Provider has to return, or asking a user for more user information before creating a login session.  
- [Protocol connection's interceptor](CodeReferences/IProtocolInterceptorService.cs): this type of interceptor is invoked before claims transformation pipeline is run. The advantage of an intercepter versus a custom claims transformation is that you can implement use cases that need user interactions.

As you can probably see now, the two interfaces have identical members and only the interface names differ. We chose that design to simplify how Identify can initiate the interceptor objects internally.

## Interceptor: further technical details

Although the members and their parameters are well-explained by comments on those code files, real trouble is on the contextId parameter, the Intercept/OnPostBack model, and mandatory form parameters.

### ContextId

The context id is generated by Identify internally and passed to interceptors. When an interceptor needs to break a login flow, e.g. when it needs to show a UI to collect inputs from a user and submit, the submit request needs to contain the context id so that Identify can restart the on-going login session.

We recommend that you add a ContextId property to your view model and set it to the contextId parameter.

### The Intercept/OnPostBack model

An interceptor has two steps:

- Intercept: the method is executed when an interceptor is called the first time.
- OnPostBack: when the interceptor shows a UI to a user and after the user submits data, Identify will call OnPostBack to handle that submission request.

Before 5.3, handling interceptor is a standalone step in a login flow so the Intercept/OnPostBack model made sense. From 5.3 we have turned interceptor into a sub step of a chain of commands happened before or after an event occurs. Ideally, there should be only the Intercept method that handles both Intercept and OnPostBack and the interceptor itself what it should do: showing something to a user or processing data submitted by the user. Anyway, in order to restrict changes that would break existing installations, we stick with the current Intercept/OnPostBack for now.

As a side note, if your interceptor doesn't need user interaction, implementation will be a lot easier because you don't need to care about the on postback phase.

### Interceptor's view: mandatory form parameters

When an interceptor shows a UI, it essentially breaks the login flow. Thus, when the interceptor view submits data to Identify, the submit request needs to post a bunch of mandatory parameters to Identify to help it "restarting" the login flow. The easiest way to do that is to render those mandatory parameters as hidden fields using a single line of code:

```cs
@Html.Partial("RenderFormParameters", new RenderFormParametersModel(Model.ContextId))
```

For example:

```cs
@using Safewhere.IdentityProvider.RuntimeModel
@using Safewhere.IdentityProviderModel
@using System.Web.Mvc.Html
@using Safewhere.External.Samples

@model SampleModel

@section TitleHeader{
    Partner Selection
}
@section InitScript{

}
@section TitleContent{
    Partner Selection
}
@section MainContent{
    <h2>You are acessing a sample application.</h2>
    <form method="post">
        @Safewhere.Web.Mvc.Security.HtmlHelper.AntiForgeryToken()

        <input type="submit" value="OK" tabindex="0" />

        @Html.Partial("RenderFormParameters", new RenderFormParametersModel(Model.ContextId))
    </form>
}
```

And the model class definition is:

```cs
    public class SampleModel
    {
        public string ContextId { get; set; }
    }
```

Remember the ContextId parameter that we recommeded you to add to your model class? This is where it is used.

Notice that there is a call to AntiForgeryToken in the sample. You will need it when your interceptor is used with a connection type whose endpoint is protected by AntiForgeryToken validation such as the Username & Password connection. What if you need to use an interceptor for both connections that supports and doesn't support AntiForgeryToken validation? You can safely put the line to render AntiForgeryToken in the view. The endpoint that doesn't support token validation will just ignore it. As a side note, security-wise all endpoints should have AntiForgeryToken validation turned on, but in practice endpoints such as Saml 2.0's are designed to receive POST requests from external systems.

## Sample code

This sample solution has 3 examples for interceptors:
- [Authentication connection's interceptor](../ExternalSamples/SocialSecurityNumberConfirmationInterceptorService.cs)
- [Protocol connection's interceptor](../ExternalSamples/PartnerSelectionInterceptorService.cs )
- [A walkthrough to implement a new interceptor](interceptor-walkthrough.md)

## Q&A
